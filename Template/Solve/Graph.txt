  CIN( int , N , M );
  // CIN( int , N ); int M = N - 1;
  vector<vector<int>> e( N );
  // vector<Set<int>> e( N );
  // vector<T2<int>> edge_enum( M );
  FOR( m , 0 , M ){
    CIN( int , i , j ); --i; --j;
    e[i] <<= j;
    e[j] <<= i;
    // edge_enum[m] = {i,j};
  }
  auto edge = Get( e );
  Graph graph{ N , edge };
  using T = decltype( graph )::type;

  // /* 状態を1次元分追加 */
  // using T = T2<int>;
  // CIN( int , K );
  // Set_HW( N , K );
  // auto edge = [&]( const T& v ){
  //   auto& [i,k] = v;
  //   vector<T> a{};
  //   RUN( e[i] , j ){
  //     if( ){
  //       a <<= {j,k+1};
  //     } else {
  //       a <<= {j,k};
  //     }
  //   }
  //   return a;
  // };
  // GridGraph graph{ edge };

  // /* （多点）幅優先探索 O(V+E) */
  // /* Geometry/Graph/Algorithm/BreadthFirstSearch/compress.txt */
  // T external_point = -1;
  // vector<T> start_points = {0};
  // BreadthFirstSearch bfs{ graph , external_point , start_points }; vector<int> d = bfs.GetDistance();
  // BreadthFirstSearch bfs{ graph , external_point }; auto [colour,colour_inv,colour_ulim] = bfs.GetConnectedComponent();

  // /* 木の深さ優先探索 O(V) */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/compress.txt */
  // DepthFirstSearchOnTree dfst{ graph , 0 };

  // /* 木DP O(V) */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/RootingDP/compress.txt */
  // /* ノードiにU型の値A[i]が定まっておりその部分木和をdp[i]に格納する場合 */
  //   auto f = [&]( vector<U> u , const int& i ){
  //     U answer = A[i];
  //     for( auto& x : u ){ answer += x; }
  //     return answer;
  //   };
  // auto x = RecursionRootingDP( graph , f , 0 );
  // /* ノードiにU型の値A[i]が定まっており型Uの非可換モノイド構造Mが与えられノード番号の全順序ordが定義されておりiの子ノードをわたるノード番号jのord昇順のMに関するdp[j]の総乗をA[i]に右から掛けたものをdp[i]に格納する場合 */
  //   auto f = [&]( vector<pair<U,int>> u , const int& i ){
  //     U answer = A[i];
  //     sort( u.begin() , u.end() , [&]( const pair<U,int>& u0 , const pair<U,int>& u1 ){ return ord( get<1>( u0 ) , get<1>( u1 ) ); } );
  //     for( auto& [x,j] : u ){ answer = M.Product( move( answer ) , x ); }
  //     return pair{ move( answer ) , i };
  //   };
  // auto x = RecursionRootingDP( graph , f , 0 );
  // /* val( i )にprodで右からiの子ノードjをわたるdp[j]を掛けた値をdp[i]に格納する場合 */
  // auto val = [&]( const int& i ){ return A[i]; };
  // auto prod = [&]( U u0 , U u1 , const int& i , const int& j ){
  //   u0 *= u1;
  //   return move( u0 );
  // };
  // auto x = BinaryRootingDP( graph , val , prod , 0 );

  // /* 素集合データ構造 O(V+Eα(V)) */
  // /* Geometry/Graph/Algorithm/UnionFindForest/compress.txt */
  // AbstractUnionFindForest uff{ graph , AdditiveGroup<int>() };
  // // AbstractUnionFindForest uff{ N , AdditiveGroup<int>() };
  // // vector<int> weight( N ); // 各連結成分のサイズを根の添え字に格納
  // // ll weight2 = N; // 連結成分サイズの2乗和を管理
  // // FOR( m , 0 , M ){
  // //   auto& [i,j] = edge_enum[m];
  // //   int ri = uff.RootOfNode( i );
  // //   int rj = uff.RootOfNode( j );
  // //   if( ri != rj ){
  // //     int wi = weight[ri];
  // //     int wj = weight[rj];
  // //     Graft( i , j );
  // //     weight[ri] = weight[rj] = wi + wj;
  // //     weight2 += 2 * ll( wi ) * wj;
  // //   }
  // // }

  // /* 無向木のトポロジカルソート O(V+E) */
  // /* Geometry/Graph/Acyclic/Tree/compres.txt */
  // /* ts[i]=トポロジカルソートでi番目のノードt */
  // /* ts_inv[t]=ノードtがトポロジカルソートで何番目か */
  // /* prev[i]=rootを根とする木のノードをts_invで数に翻訳して得られる根付き木におけるiのprev */
  // /* dir_edge[i]={上記根付き木におけるiの子ノード番号全体}、つまり有向辺データ */
  // int root=0;
  // auto [ts,ts_inv,prev,dir_edge] = TopologicalSortedTree( graph , root );
  // Graph graph_dir{ N , Get( dir_edge ) }; // トポロジカルソートされた根付き木の有向化
  // Graph graph_dir_rev{ N , [&]( const int& i ){ return vector( prev[i] >= 0 ? 1 : 0 , prev[i] ); } }; // トポロジカルソートされた根付き木の有向化の辺を逆にした有向木
