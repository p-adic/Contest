  CIN( int , N , M );
  // CIN( int , N ); int M = N - 1;
  CIN_A( T2<int> , 0 , M , UV ); --UV;
  // vector<T2<int>> UV( N );
  // Map<T2<int>,int> UV_inv{};
  vector<vector<int>> e( N );
  // vector<Set<int>> e( N );
  // vector<vector<int>> e_inv( N ); // 有向グラフの逆辺
  FOR( m , 0 , M ){
    auto& [u,v] = UV[m];
    // CIN( int , u , v ); --u; --v;
    e[u] <<= v;
    e[v] <<= u;
    // e_inv[v] <<= u;
    // UV[m] = {u,v};
    // UV_inv[{u,v}] = UV_inv[{v,u}] = m;
  }
  auto edge = Get( e );
  Graph graph{ N , edge };

  // /* 状態を1次元分追加 */
  // using T = T2<int>;
  // CIN( int , K );
  // Set_HW( N , K );
  // auto edge = [&]( const T& v ){
  //   auto& [i,k] = v;
  //   vector<T> a{};
  //   RUN( e[i] , j ){
  //     if( ){
  //       a <<= {j,k+1};
  //     } else {
  //       a <<= {j,k};
  //     }
  //   }
  //   return a;
  // };
  // GridGraph graph{ edge };

  // /* （多点）幅優先探索 O(V+E) */
  // /* Geometry/Graph/Algorithm/BreadthFirstSearch/ */
  // using T = decltype( graph )::type;
  // T external_point = -1;
  // vector<T> start_points = {0};
  // BreadthFirstSearch bfs{ graph , external_point , start_points }; vector<int> d = bfs.GetDistance();
  // BreadthFirstSearch bfs{ graph , external_point }; auto [colour,colour_inv,colour_ulim] = bfs.GetConnectedComponent();

  // /* 木の深さ優先探索 O(V) */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/ */
  // DepthFirstSearchOnTree dfst{ graph , 0 };

  // /* 木DP O(V) */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/RootingDP/ */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/RootingDP/Recursion/ */
  // /* ノードiにU型の値A[i]が定まっておりその部分木和をdp[i]に格納する場合 */
  // using U = ll;
  // auto f = [&]( vector<U> u = {} , const int& i = 0 ){
  //   U answer = A[i];
  //   for( auto& x : u ){ answer += x; }
  //   return answer;
  // };
  // auto dp = RootingDP( dfst , f );
  // // auto val = RecursionRootingDP( graph , f , 0 );
  // /* 辺mにU型の値A[m]が定まっており、ノードiの部分木和+(iが根?U{}:A[iの親への辺番号])を
  //   dp[i]に格納する場合*/
  // using U = ll;
  // auto f = [&]( vector<U> u = {} , const int& i = 0 ){
  //   U answer = i == root ? U{} : A[UV_inv[{i,dfst.Parent(i)}]];
  //   for( auto& x : u ){ answer += x; }
  //   return answer;
  // };
  // auto dp = RootingDP( dfst , f );
  // /* ノードiにU型の値A[i]が定まっており型Uの非可換モノイド構造Mが与えられノード番号の全順序ordが定義されておりiの子ノードをわたるノード番号jのord昇順のMに関するdp[j]の総乗をA[i]に右から掛けたものをdp[i]に格納する場合 */
  // using U = ll;
  // auto f = [&]( vector<Pair<U,int>> u = {} , const int& i = 0 ){
  //   U answer = A[i];
  //   sort( u.begin() , u.end() , [&]( const pair<U,int>& u0 , const pair<U,int>& u1 ){ return ord( get<1>( u0 ) , get<1>( u1 ) ); } );
  //   for( auto& [x,j] : u ){ answer = M.Product( move( answer ) , x ); }
  //   return pair{ move( answer ) , i };
  // };
  // auto dp = RootingDP( dfst , f );
  // // auto val = RecursionRootingDP( graph , f , 0 );
  // /* f( i )にprodで右からiの子ノードjをわたるdp[j]を掛けた値をdp[i]に格納する場合 */
  // using U = ll;
  // auto f = [&]( const int& i ){ return A[i]; };
  // auto prod = [&]( U u0 , U u1 , const int& i , const int& j ){
  //   u0 *= u1;
  //   return move( u0 );
  // };
  // auto val = BinaryRootingDP( graph , f , prod , 0 );

  // /* 全方位木DP O(V) */
  // /* Geometry/Graph/Algorithm/DepthFirstSearch/Tree/RootingDP/Rerooting/ */
  // /*「パスの数」を求める場合 */
  // AdditiveMonoid<int> monoid{};
  // auto f = [&]( const int& u , const int& i ){ return u + 1; };
  // auto g = [&]( cost int& u , const bool& is_child , const int& k , const int& j ){ return u; };
  // auto dp = RerootingDP( dfst , monoid , f , g );
  // /*「パスの長さの最大値」を求める場合 */
  // MaxSemilattive<int> monoid{ -1 };
  // auto f = [&]( const int& u , const int& i ){ return u + 1; };
  // auto g = [&]( cost int& u , const bool& is_child , const int& k , const int& j ){ return u; };
  // auto dp = RerootingDP( dfst , monoid , f , g );
  // /* ノードiにU型の値A[i]が定まっており型Uの可換モノイド構造monoidが与えられiを根としてノードjの
  //    子ノードkをわたって(iを根としてkが葉?A[k]:dp[i][k])の総和をdp[i][j]に格納する場合 */
  // auto f = [&]( const U& u , const int& i ){ return u; };
  // auto g = [&]( cost U& u , const bool& is_child , const int& k , const int& j ) { return dfst.IsLeaf( i , k ) ? A[k] : u; };
  // auto dp = RerootingDP( dfst , monoid , f , g );
  // /* ノードiにU型の値A[i]が定まっており型Uの可換モノイド構造monoidが与えられiを根として
  //   (ノードjが葉?A[j]:jの子ノードkをわたるdp[i][k]の総和)をdp[i][j]に格納する場合は、
  //   dp[i][i]=(size=1?A[i]:上のケースのdp[i][i])で処理可能 */
  // /* 並び換え不変な関数h:U^{< omega} -> Uが与えられており
  //    h(iを根とした時のjの子ノードkをわたるdp][i][k]たち)をdp[i][j]に格納する場合 */
  // auto concate = [&]( vector<U> v0 ,  const vector<U>& v1 ){
  //   RUN( v1 , u ){ v0 <<= u; }
  //   return move( v0 );
  // };
  // vector<U> empty{}:
  // AbstractMonoid monoid{ concat , empty };
  // auto f = [&]( const vector<U>& v , const int& i ){ return vector<U>{ h( v ) }; };
  // auto g = [&]( cost vector<U>& v , const bool& is_child , const int& k , const int& j ) -> const vector<U>& { return v; };
  // auto dp = RerootingDP( dfst , monoid , f , g );

  // /* 素集合データ構造 O(V+Eα(V)) */
  // /* Geometry/Graph/Algorithm/UnionFindForest/ */
  // UnionFindForest uff{ N };
  // // vector<int> weight( N , 1 ); // 各連結成分のサイズを根の添え字に格納
  // // ll weight2 = N; // 連結成分サイズの2乗和を管理
  // // AbstractUnionFindForest uff{ graph , AdditiveGroup<int>() };
  // // // vector<int> weight( N );
  // // // FOR( i , 0 , N ){
  // // //   auto ri = uff.RootOfNode( i );
  // // //   weight[ri]++;
  // // // }
  // // // ll weight2 = 0;
  // // // FOR( i , 0 , N ){
  // // //   weight2 += ll( weight[ri] ) * weight[ri];
  // // // }
  // // FOR( m , 0 , M ){
  // //   auto& [i,j] = UV[m];
  // //   auto ri = uff.RootOfNode( {h0,w0} );
  // //   auto rj = uff.RootOfNode( {h1,w1} );
  // //   if( ri != rj ){
  // //     int wi = weight[ri];
  // //     int wj = weight[rj];
  // //     uff.Graft( ri , rj );
  // //     weight[ri] = weight[rj] = wi + wj;
  // //     weight2 += 2 * ll( wi ) * wj;
  // //   }
  // // }

  // /* 無向木のトポロジカルソート O(V+E) */
  // /* Geometry/Graph/Acyclic/Tree/compres.txt */
  // /* ts[i]=トポロジカルソートでi番目のノードt */
  // /* ts_inv[t]=ノードtがトポロジカルソートで何番目か */
  // /* prev[i]=rootを根とする木のノードをts_invで数に翻訳して得られる根付き木におけるiのprev */
  // /* dir_edge[i]={上記根付き木におけるiの子ノード番号全体}、つまり有向辺データ */
  // int root=0;
  // auto [ts,ts_inv,prev,dir_edge] = TopologicalSortedTree( graph , root );
  // Graph graph_dir{ N , Get( dir_edge ) }; // トポロジカルソートされた根付き木の有向化
  // Graph graph_dir_rev{ N , [&]( const int& i ){ return vector( prev[i] >= 0 ? 1 : 0 , prev[i] ); } }; // トポロジカルソートされた根付き木の有向化の辺を逆にした有向木
