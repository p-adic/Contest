  CIN( int , N , M );
  // CIN( ll , K );
  // 以下、ライブラリは重複しうるので下に位置するライブラリを優先でC-x C-lする。
  
  // /* 素数列挙 O(N log log N) */
  // /* Arithmetic/Prime/Enumeration/Heap/ */
  // /* Arithmetic/Prime/Enumeration/ (要高速化時) */
  // /* val_limit = 316 ≒ sqrt(1e5) -> length = 65 */
  // /* val_limit = 448 ≒ sqrt(2e5) -> length = 86 */
  // /* val_limit = 1e5 -> length = 9592           */
  // /* val_limit = 1e6 -> length = 78498          */
  // CEXPR( int , val_limit , 316 );
  // static HeapPrimeEnumeration pe{ val_limit };
  // // constexpr PrimeEnumeration<val_limit> pe{};
  // // auto& length = pe.length();

  // /* 最小素因数 */
  // /* Arithmetic/Divisor/Least/Heap/ */
  // /* Arithmetic/Divisor/Least/ (要高速化時) */
  // CEXPR( int , val_limit , 316 );
  // static HeapLeastDivisor ld{ val_limit };
  // // constexpr LeastDivisor<val_limit> ld{};

  // /* 素因数分解 O(pe:√N/log N,ld:log N) */
  // /* Arithmetic/Prime/Factrisation/ */
  // auto [pf,e] = PrimeFactorisation( pe , N );
  // // auto [pf,e,q] = PrimePowerFactorisation( pe , N );

  // /* 約数計数 O(pe:√N/log N,ld:log N) */
  // /* Arithmetic/Divisor/Count/ */
  // /* n <= 1e3 -> answer <= 32  */
  // /* n <= 1e4 -> answer <= 64  */
  // /* n <= 1e5 -> answer <= 128 */
  // /* n <= 1e6 -> answer <= 256 */
  // int count = CountDivisor( pe , N );

  // /* 約数列挙 O(pe:√N/log N,ld:d(N)=N^{log 2/log log N}) */
  // /* Arithmetic/Divisor/Enumeration/ */
  // vector<int> div = EnumerateDivisor( pe , N ); Sort( div );
  // // /* N以下の各iに対するiの約数列挙 */
  // // vector<vector<int>> div = TotalEnumerateDivisor( N ); // O(N log N)

  // /* オイラー関数  O(√N/log N)/O(log N) */
  // /* Arithmetic/Mod/Function/Euler/ */
  // int euler = EulerFunction( pe , N );
  // // /* N以下の各iに対するiのオイラー関数計算 */
  // // vector<int> euler = TotalEulerFunction( pe , N ); // O(N log N)

  // /* 桁DP */
  // using T = MP;
  // string S = to_string( N );
  // // CEXPR( int , base , 10 );
  // // vector<int> S = AdicExpansion( N , base );
  // int D = S.size();
  // /* {現在の桁でN未満確定の解,現在の桁でN以下確定の解} */
  // /* base-1の約数の倍数判定をしたい場合は桁和mod(base-1)ごとに管理 */
  // T2<T> dp{0,1};
  // /* dp[O]からdp[O]への遷移をここに書く。*/
  // auto fltlt = [&]( const T& t , const int& d ){
  //   return t * base;
  // };
  // /* dp[I]からdp[O]への遷移をここに書く。*/
  // auto feqlt = [&]( const T& t , const int& d ){
  //   return t * ( S[d] - '0' );
  // };
  // /* dp[I]からdp[I]への遷移をここに書く。*/
  // auto feqeq = [&]( const T& t , const int& d ){
  //   return t;
  // };
  // FOR( d , 0 , D ){
  //   dp = { fltlt( dp[O] , d ) + feqlt( dp[I] , d ) , feqeq( dp[I] , d ) };
  // }
  // T a = dp[O] + dp[I];

  // /* 再帰 */
  // /* Function/Recursion/ */
  // Recursion( int , f , const int& n ){
  //   return n <= 1 ? n : ( f( n - 1 ) + f( n - 2 ) ) % 1000000007;
  // };
  // MemoRecursion( int , f , const int& n ){
  //   return n <= 1 ? n : ( f( n - 1 ) + f( n - 2 ) ) % 1000000007;
  // };

