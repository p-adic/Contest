  CIN( int , N , M );
  // CIN( int , N ); int M = N - 1;
  using weight_type = ll;
  using path_type = Tuple<int,weight_type>;
  vector<vector<path_type>> e( N );
  // vector<Tuple<int,int,weight_type>> wedge_enum( M );
  // vector<Tuple<int,int>> edge_enum( M );
  // vector<weight_type> weight_enum( M );
  // CEXPR( weight_type , infty , 1e18 );
  // vector weight( N , vector( N , infty ) ); FOR( i , 0 , N ){ weight[i][i] = 0; }
  // CIN_AA( weight_type , 0 , N , 0 , N , weight );
  FOR( m , 0 , M ){
    CIN( int , i , j ); --i; --j;
    CIN( ll , w );
    e[i].push_back( {j,w} );
    e[j].push_back( {i,w} );
    // wedge_enum[m] = {i,j,w};
    // edge_enum[m] = {i,j};
    // weight_enum[m] = w;
    // weight[i][j] = weight[j][i] = w;
  }
  auto edge = Get( e );
  // auto edge = [&]( const int& i ){
  //   vector<path> answer{};
  //   FOR( j , 0 , N ){
  //     answer.push_back( { j , weight[i][j] } );
  //   }
  //   return answer;
  // };
  Graph graph{ N , edge };

  // /* ダイクストラ法 O(min(V^2+E,(V+E)log E)) */
  // /* Geometry/Graph/Algorithm/Dijkstra/compress.txt */
  // Dijkstra dijk{ graph }; vector<decldecay_t(dijk.Infty())> d = dijk.GetDistance( 0 );
  
  // /* 最小全域森 O(Eα(V+log E)) */
  // /* Geometry/Graph/Algorithm/UnionFindForest/Kruscal/compress.txt */
  // /* chosen_edge_num={選択された辺の番号全体} */
  // /* cc_size=連結成分数 */
  // AbstractUnionFindForest uff{ graph , AdditiveGroup<ll>() };
  // auto [chosen_edge_num,cc_size] = Kruscal( graph );

  // /* ワーシャルフロイド法 O(V^3) */
  // /* Geometry/Graph/Algorithm/FloydWarshall/compress.txt */
  // FloydWarshall fw{ infty , weight }; FOR( i , 0 , N ){ FOR( j , 0 , N ){ auto& d = fw.Get( i , j ); COUTNS( d == infty ? -1 : infty , " \n"[j==N-1] ); } }

  // /* ヘルドカープ法 O((V+E)2^{経由すべき点の個数}) */
  // /* Geometry/Graph/Algorithm/HeldKarp/compress.txt */
  // HeldKarp hk{ graph }; vector<weight_type> d = hk.GetDistance( 0 , id<int>( N ) , true );

