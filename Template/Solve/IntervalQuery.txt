  CIN( int , N );
  CIN_A( MP , 0 , N , A );
  // CIN_A( int , 0 , N , A );
  // CIN_A( ll , 0 , N , A );
  // CIN( string , S );
  CIN( int , Q ); // 入力受け取り順に注意
  // (1) 最下部に必要なクエリ処理を書く。
  // (2) ここに必要な代数構造とX_preの定義をする。
  // (3) 以下のデータ構造を選択する。
  // using U = MP;
  // auto op = [&]( U u0 , const U& u1 ){
  //   u0 += u1;
  //   return move( u0 );
  // };
  // U unit{};
  // auto inv = [&]( const U& u ){
  //   return -u;
  // };
  // AbstractGroup G{ op , unit , inv };
  
  // auto& X_pre = A;
  // // vector<U> X_pre( N );

  // /* 累積和 O(N)/O(1) */
  // /* SetTheory/DirectProduct/AffineSpace/CumulativeProduct/ */
  // CumulativeSum X( move( X_pre ) );

  // /* 階差数列 O(N)/O(1) */
  // /* SetTheory/DirectProduct/AffineSpace/DifferenceSequence/ */
  // DifferenceSequence X( move( X_pre ) );

  // /* 排他的スパーステーブル O(N log N)/O(__builtin_clzの計算量) */
  // /* 空間計算量もO(N log N)であることに注意 */
  // /* SetTheory/DirectProduct/AffineSpace/DisjointSparseTable/ */
  // DisjointSparseTable X( X_pre ); // 最大値の管理
  // // AbstractDisjointSparseTable X( MinSemilattice<decltype(X_pre[0])>( 1e9 ) , X );
  // // AbstractDisjointSparseTable X( MultiplicativeMonoid<decltype(X_pre[0])>( 1 ) , X );

  // /* フェニック木 O(N)/O(log N) */
  // /* SetTheory/DirectProduct/AffineSpace/BIT/ */
  // BIT bit{ X_pre };
  // // /* SetTheory/DirectProduct/AffineSpace/BIT/IntervalAdd/ */
  // // IntervalAddBIT X{ X_pre };
  // // /* SetTheory/DirectProduct/AffineSpace/BIT/IntervalMax/ */
  // // IntervalMaxBIT X{ decltype(X_pre[0])( 0 ) , X_pre };
  // // IntervalMinBIT X{ decltype(X_pre[0])( 1e9 ) , X_pre };

  // /* セグメント木 O(N)/O(log N) */
  // /* SetTheory/DirectProduct/AffineSpace/SegmentTree/ */
  // int val_min = -1; SegmentTree X{ val_min , X_pre }; // 最大値の管理
  // // AbstractSegmentTree X{ MinSemilattice<decltype(X_pre[0])>( 1e9 ) , X_pre };
  // // AbstractSegmentTree X{ MultiplicativeMonoid<decltype(X_pre[0])>( 1 ) , X_pre };

  // /* 平方分割 O(N)/O(√N) */
  // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/ */
  // SqrtDecomposition X{ move( X_pre ) };
  // // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/IntervalAdd/ */
  // // IntervalAddSqrtDecomposition X{ move( X_pre ) };
  // // /* モノイド */
  // // AbstractMonoid monoid{[&](int t0,const int& t1){return move(t0<t1?t0=t1:t0);},0}; // 区間max更新を処理する場合
  // // MultiplicativeMonoid<decldecay_t(X_pre[0])> monoid{1}; // 区間乗算更新を処理する場合
  // // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Dual/ */
  // // DualSqrtDecomposition X{ RegularRSet( monoid ) , RegularRSet{ monoid } , move( X_pre ) };
  // // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Dual/Commutative/ */
  // // CommutativeDualSqrtDecomposition X{ RegularRSet( monoid ) , RegularRSet{ monoid } , move( X_pre ) };
 // // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Lazy/ */
  // // LazySqrtDecomposition X{ MultiplicativeMonoid<MP>{ 1 } , BiModule<MP,int,MP>{} , move( X_pre ) }; // 区間乗算更新と区間和取得を処理する場合
  // // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Lazy/IntervalMultiply/ */
  // // IntervalMultiplyLazySqrtDecomposition X{ RegularRSet{ MultiplicativeMonoid<MP>{ 1 ) } , Module<MP,MP>{} , move( X_pre ) }; // 区間乗算更新と区間加算更新と区間和取得を処理する場合
  // // GeometricProgressionMinDualSqrtDecomposition X{ Module<int,int>{} , int( 1e9 ) , {1,-1} , move( X_pre ) }; // 区間一次式min更新と一点取得を処理する場合
  // // /* Algebra/Monoid/Group/DirectSum/ */
  // // int index = -1 , dim = 26;
  // // DirectSumGroup dsg{ group , index , dim }; // 自由加群
  // // AbstractSqrtDecomposition X{ dsg , N };
  // // FOR( i , 0 , N ){ X.Set( i , dsg.Wrap( X_pre[i] ) ); }

  // vector<T3<int>> query( Q );
  FOR( q , 0 , Q ){
    CIN( int , l , r ); --l; --r;
    // query[q] = {l,r,q};
    // COUT( X.IntervalSum( l , r ) );
  }
  // Sort( query );

  // /* Moのアルゴリズム O(min(X+Q,Q log Q))/合計O((X+Q)√Y) */
  // /* SetTheory/DirectProduct/AffineSpace/SqrtDecomposition/Mo/ */
  // Mo mo{ query };
  
  // RUN( query , [l,r,q] ){
  
  // }
